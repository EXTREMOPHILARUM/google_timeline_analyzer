"""Initial schema from SQLAlchemy models

Revision ID: 557dc3368045
Revises: 
Create Date: 2025-12-28 07:42:33.222754

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import geoalchemy2
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '557dc3368045'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # PostGIS extension is already enabled in the postgis/postgis Docker image
    # No need to create it here

    op.create_table('places',
    sa.Column('place_id', sa.String(length=100), nullable=False),
    sa.Column('name', sa.String(length=500), nullable=True),
    sa.Column('formatted_address', sa.String(), nullable=True),
    sa.Column('types', sa.ARRAY(sa.String()), nullable=True),
    sa.Column('location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('rating', sa.Float(), nullable=True),
    sa.Column('user_ratings_total', sa.Integer(), nullable=True),
    sa.Column('price_level', sa.Integer(), nullable=True),
    sa.Column('photo_references', sa.ARRAY(sa.String()), nullable=True),
    sa.Column('business_status', sa.String(length=50), nullable=True),
    sa.Column('api_response', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('last_updated', sa.DateTime(timezone=True), nullable=True),
    sa.Column('fetch_attempts', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('place_id')
    )
    # Note: GIST index for location is auto-created by GeoAlchemy2
    op.create_table('timeline_segments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('segment_type', sa.String(length=20), nullable=False),
    sa.Column('start_time', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_time', sa.DateTime(timezone=True), nullable=False),
    sa.Column('timezone_offset_minutes', sa.Integer(), nullable=True),
    sa.Column('raw_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_timeline_segments_segment_type'), 'timeline_segments', ['segment_type'], unique=False)
    op.create_index(op.f('ix_timeline_segments_start_time'), 'timeline_segments', ['start_time'], unique=False)

    # Add generated column for duration_seconds (computed from start_time and end_time)
    op.execute("""
        ALTER TABLE timeline_segments
        ADD COLUMN duration_seconds INTEGER
        GENERATED ALWAYS AS (
            EXTRACT(EPOCH FROM (end_time - start_time))::INTEGER
        ) STORED
    """)

    op.create_table('travel_mode_affinities',
    sa.Column('mode', sa.String(length=50), nullable=False),
    sa.Column('affinity', sa.Float(), nullable=True),
    sa.PrimaryKeyConstraint('mode')
    )
    op.create_table('activities',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('segment_id', sa.Integer(), nullable=True),
    sa.Column('start_location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('end_location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('distance_meters', sa.Float(), nullable=True),
    sa.Column('activity_type', sa.String(length=50), nullable=True),
    sa.Column('probability', sa.Float(), nullable=True),
    sa.ForeignKeyConstraint(['segment_id'], ['timeline_segments.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('segment_id')
    )
    # Note: GIST indexes for start_location and end_location are auto-created by GeoAlchemy2
    op.create_index(op.f('ix_activities_activity_type'), 'activities', ['activity_type'], unique=False)
    op.create_index(op.f('ix_activities_distance_meters'), 'activities', ['distance_meters'], unique=False)
    op.create_table('timeline_memories',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('segment_id', sa.Integer(), nullable=True),
    sa.Column('distance_from_origin_kms', sa.Integer(), nullable=True),
    sa.Column('destination_place_ids', sa.ARRAY(sa.String()), nullable=True),
    sa.ForeignKeyConstraint(['segment_id'], ['timeline_segments.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('segment_id')
    )
    op.create_table('timeline_paths',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('segment_id', sa.Integer(), nullable=True),
    sa.Column('location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('recorded_at', sa.DateTime(timezone=True), nullable=False),
    sa.ForeignKeyConstraint(['segment_id'], ['timeline_segments.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    # Note: GIST index for location is auto-created by GeoAlchemy2
    op.create_index(op.f('ix_timeline_paths_recorded_at'), 'timeline_paths', ['recorded_at'], unique=False)
    op.create_table('trips',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('start_time', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_time', sa.DateTime(timezone=True), nullable=False),
    sa.Column('origin_place_id', sa.String(length=100), nullable=True),
    sa.Column('is_multi_day', sa.Boolean(), nullable=True),
    sa.Column('total_distance_meters', sa.Float(), nullable=True),
    sa.Column('primary_transport_mode', sa.String(length=50), nullable=True),
    sa.Column('detection_algorithm', sa.String(length=50), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['origin_place_id'], ['places.place_id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_trips_start_time'), 'trips', ['start_time'], unique=False)
    op.create_table('user_profile',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('home_place_id', sa.String(length=100), nullable=True),
    sa.Column('work_place_id', sa.String(length=100), nullable=True),
    sa.Column('home_location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('work_location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.ForeignKeyConstraint(['home_place_id'], ['places.place_id'], ),
    sa.ForeignKeyConstraint(['work_place_id'], ['places.place_id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # Note: GIST indexes for home_location and work_location are auto-created by GeoAlchemy2
    op.create_table('visits',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('segment_id', sa.Integer(), nullable=True),
    sa.Column('place_id', sa.String(length=100), nullable=True),
    sa.Column('semantic_type', sa.String(length=50), nullable=True),
    sa.Column('probability', sa.Float(), nullable=True),
    sa.Column('location', geoalchemy2.types.Geography(geometry_type='POINT', srid=4326, dimension=2, from_text='ST_GeogFromText', name='geography'), nullable=True),
    sa.Column('hierarchy_level', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['segment_id'], ['timeline_segments.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('segment_id')
    )
    # Note: GIST index for location is auto-created by GeoAlchemy2
    op.create_index(op.f('ix_visits_place_id'), 'visits', ['place_id'], unique=False)
    op.create_index(op.f('ix_visits_semantic_type'), 'visits', ['semantic_type'], unique=False)
    op.create_table('trip_destinations',
    sa.Column('trip_id', sa.Integer(), nullable=False),
    sa.Column('place_id', sa.String(length=100), nullable=False),
    sa.Column('visit_order', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['place_id'], ['places.place_id'], ),
    sa.ForeignKeyConstraint(['trip_id'], ['trips.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('trip_id', 'place_id')
    )
    op.create_table('trip_segments',
    sa.Column('trip_id', sa.Integer(), nullable=False),
    sa.Column('segment_id', sa.Integer(), nullable=False),
    sa.Column('segment_order', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['segment_id'], ['timeline_segments.id'], ),
    sa.ForeignKeyConstraint(['trip_id'], ['trips.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('trip_id', 'segment_id')
    )

    # Create database views for common queries

    # View 1: Recent trips with destinations
    op.execute("""
        CREATE OR REPLACE VIEW recent_trips_with_destinations AS
        SELECT
            t.id,
            t.start_time,
            t.end_time,
            t.total_distance_meters / 1000 AS distance_km,
            EXTRACT(EPOCH FROM (t.end_time - t.start_time)) / 3600 AS duration_hours,
            t.primary_transport_mode,
            t.detection_algorithm,
            array_agg(p.name ORDER BY td.visit_order) AS destination_names,
            array_agg(p.place_id ORDER BY td.visit_order) AS destination_place_ids
        FROM trips t
        LEFT JOIN trip_destinations td ON t.id = td.trip_id
        LEFT JOIN places p ON td.place_id = p.place_id
        GROUP BY t.id, t.start_time, t.end_time, t.total_distance_meters,
                 t.primary_transport_mode, t.detection_algorithm
    """)

    # View 2: Most visited places
    op.execute("""
        CREATE OR REPLACE VIEW most_visited_places AS
        SELECT
            v.place_id,
            p.name,
            p.formatted_address,
            COUNT(v.id) AS visit_count,
            MIN(ts.start_time) AS first_visit,
            MAX(ts.start_time) AS last_visit,
            p.rating,
            p.types
        FROM visits v
        JOIN timeline_segments ts ON v.segment_id = ts.id
        LEFT JOIN places p ON v.place_id = p.place_id
        WHERE v.semantic_type NOT IN ('HOME', 'WORK', 'INFERRED_HOME', 'INFERRED_WORK')
        GROUP BY v.place_id, p.name, p.formatted_address, p.rating, p.types
        ORDER BY visit_count DESC
    """)

    # View 3: Activity statistics
    op.execute("""
        CREATE OR REPLACE VIEW activity_statistics AS
        SELECT
            a.activity_type,
            COUNT(*) AS activity_count,
            SUM(a.distance_meters) / 1000 AS total_km,
            AVG(a.distance_meters) / 1000 AS avg_km_per_activity,
            SUM(ts.duration_seconds) / 3600 AS total_hours
        FROM activities a
        JOIN timeline_segments ts ON a.segment_id = ts.id
        GROUP BY a.activity_type
        ORDER BY total_km DESC
    """)

    # View 4: Yearly travel statistics
    op.execute("""
        CREATE OR REPLACE VIEW yearly_travel_statistics AS
        SELECT
            EXTRACT(YEAR FROM ts.start_time) AS year,
            COUNT(DISTINCT CASE WHEN ts.segment_type = 'visit' THEN ts.id END) AS visit_count,
            COUNT(DISTINCT CASE WHEN ts.segment_type = 'activity' THEN ts.id END) AS activity_count,
            SUM(CASE WHEN ts.segment_type = 'activity' THEN a.distance_meters ELSE 0 END) / 1000 AS total_km,
            COUNT(DISTINCT v.place_id) AS unique_places_visited
        FROM timeline_segments ts
        LEFT JOIN activities a ON ts.id = a.segment_id
        LEFT JOIN visits v ON ts.id = v.segment_id
        GROUP BY year
        ORDER BY year
    """)

    # Create custom PostGIS functions

    # Function 1: Calculate distance between two places
    op.execute("""
        CREATE OR REPLACE FUNCTION calculate_distance_km(place1_id VARCHAR, place2_id VARCHAR)
        RETURNS FLOAT AS $$
        DECLARE
            distance FLOAT;
        BEGIN
            SELECT ST_Distance(p1.location, p2.location) / 1000 INTO distance
            FROM places p1, places p2
            WHERE p1.place_id = place1_id AND p2.place_id = place2_id;

            RETURN distance;
        END;
        $$ LANGUAGE plpgsql
    """)

    # Function 2: Find places within radius
    op.execute("""
        CREATE OR REPLACE FUNCTION find_places_within_radius(
            center_lat FLOAT,
            center_lng FLOAT,
            radius_km FLOAT
        )
        RETURNS TABLE (
            place_id VARCHAR,
            name VARCHAR,
            formatted_address TEXT,
            distance_km FLOAT
        ) AS $$
        BEGIN
            RETURN QUERY
            SELECT
                p.place_id,
                p.name,
                p.formatted_address,
                ST_Distance(
                    p.location,
                    ST_SetSRID(ST_MakePoint(center_lng, center_lat), 4326)::geography
                ) / 1000 AS distance_km
            FROM places p
            WHERE ST_DWithin(
                p.location,
                ST_SetSRID(ST_MakePoint(center_lng, center_lat), 4326)::geography,
                radius_km * 1000
            )
            ORDER BY distance_km;
        END;
        $$ LANGUAGE plpgsql
    """)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # Drop custom functions
    op.execute('DROP FUNCTION IF EXISTS find_places_within_radius')
    op.execute('DROP FUNCTION IF EXISTS calculate_distance_km')

    # Drop views
    op.execute('DROP VIEW IF EXISTS yearly_travel_statistics')
    op.execute('DROP VIEW IF EXISTS activity_statistics')
    op.execute('DROP VIEW IF EXISTS most_visited_places')
    op.execute('DROP VIEW IF EXISTS recent_trips_with_destinations')

    # Drop generated column (will be dropped with table, but explicit for clarity)
    op.execute('ALTER TABLE timeline_segments DROP COLUMN IF EXISTS duration_seconds')

    op.drop_table('trip_segments')
    op.drop_table('trip_destinations')
    op.drop_index(op.f('ix_visits_semantic_type'), table_name='visits')
    op.drop_index(op.f('ix_visits_place_id'), table_name='visits')
    # GIST index for location is auto-dropped with table
    op.drop_table('visits')
    # GIST indexes for home_location and work_location are auto-dropped with table
    op.drop_table('user_profile')
    op.drop_index(op.f('ix_trips_start_time'), table_name='trips')
    op.drop_table('trips')
    op.drop_index(op.f('ix_timeline_paths_recorded_at'), table_name='timeline_paths')
    # GIST index for location is auto-dropped with table
    op.drop_table('timeline_paths')
    op.drop_table('timeline_memories')
    op.drop_index(op.f('ix_activities_distance_meters'), table_name='activities')
    op.drop_index(op.f('ix_activities_activity_type'), table_name='activities')
    # GIST indexes for start_location and end_location are auto-dropped with table
    op.drop_table('activities')
    op.drop_table('travel_mode_affinities')
    op.drop_index(op.f('ix_timeline_segments_start_time'), table_name='timeline_segments')
    op.drop_index(op.f('ix_timeline_segments_segment_type'), table_name='timeline_segments')
    op.drop_table('timeline_segments')
    # GIST index for location is auto-dropped with table
    op.drop_table('places')
    # ### end Alembic commands ###
